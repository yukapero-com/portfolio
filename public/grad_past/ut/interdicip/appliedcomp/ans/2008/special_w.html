<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース 2008年度 冬季募集 専門科目</title>
<!--#include virtual="/common/header.html" -->
</head>
<body>
<!--#include virtual="/common/navbar.html" -->	

	<div class="container well well-lg" style="background: red well">
		<h3>
			東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース<br>2008年度 冬季募集 専門科目
		</h3>
		<hr />

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第2問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>スパニング木、スパニングツリー、極大木とも言う。</p>
				<p>あるグラフの全ての頂点と、そのグラフを構成する辺の一部分のみで構成される木のこと。木なので、閉路があってはならない。完全グラフから、閉路を構成する辺を取り除いたものとも言える。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>辺に重み定義されているグラフにおいて、全ての頂点を含む木で辺の重みが最小のものを、そのグラフの最小全域木と呼ぶ。閉路を含まない。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>・クラスカル法</p>
				<p>１，グラフの各頂点がそれぞれの木に属する森Fを生成する。</p>
				<p>２，グラフの辺の集合をEとする。</p>
				<p>３，Eから最も重みの小さい辺eを取り出し、削除する。その際にeに繋がる２つの頂点が別々の木に属しているならば、辺eを森Fに加え、２つの木を連結して一つの木にする。</p>
				<p>４，３をEが空集合になるまで繰り返す。</p>
				<p>５，最終的にFが最小全域木となる。</p>
				<br> <br>

				<h2>(4)</h2>
				<p>コスト：２９</p>
				<p>※グラフMは問題のもの流用のため載せられず。</p>
			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第3問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>ページング方式では、ページテーブルによって論理アドレスを物理アドレスに変換する。ページテーブルは論理アドレスをもとに主記憶装置の物理アドレスか補助記憶装置の物理アドレスを指し示し、目的とするデータの属するページが補助記憶装置上にある場合はページフォールトであり、主記憶にスワップインした後に改めてページを読み込む。また、ページテーブルにアクセスする前に、アクセスしたページの履歴情報をキャッシュメモリ内に保持しているTLBで検索することによりアクセスの高速化が望める。TLBは時間的局所性、空間的局所性の性質からして適していると言える。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>・内部フラグメンテーション</p>
				<p>メモリ管理をブロック単位で行う場合に発生する。ある３．５ブロックの容量を必要とするデータをメモリ上に置く際には４ブロックを確保して格納する。しかしながら４ブロック目は０．５ブロック、すなわち半分しか使われておらず、半ブロック分は無駄な空きが生じていることになる。これを内部フラグメンテーションと言う。</p>
				<br>
				<p>・外部フラグメンテーション</p>
				<p>メモリ管理を可変長で管理する際に発生する。メモリ上で領域の確保と開放を繰り返すとメモリ上に飛び飛びの大小様々な未割り当て領域が発生する。この時、小さい未割り当て領域が過度にあると、それよりも大きい領域を必要とする割り当て要求が来た場合に割り当てる領域が出来ない状況が発生する。これを外部フラグメンテーションと言う。メモリコンパクションによって解決可能であるが、そのために掛かるコストは無視出来ない。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>・同一にする場合</p>
				<p>同一の論理記憶空間にあるため、複数のタスク間で共通資源を持つことが可能であり、タスク同士で協調して一つの処理を行うことが可能。資源の排他制御が必要。また、メモリ領域を多く必要とするようなタスクの場合は互いに論理アドレス空間を圧迫し合う可能性がある。</p>
				<br>
				<p>・分離する場合</p>
				<p>上記で述べたアクセスの制限、データの保護をする必要が無く、一つのタスクが論理アドレス分の領域を使用することが出来るが、他のタスクと共通領域を持つことが出来ない。他のタスクの論理記憶空間上にあるデータを他のタスクが必要とする場合は、自分の論理記憶空間上にコピーする手間（プロセス間通信）が掛かってしまう。しかしプロセス間通信自体が排他制御の機能を持つためにそのための機構は不要となり管理が楽。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第4問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>初期条件として、</p>
				<p>out(HEAD,0)</p>
				<p>out(LAST,0)</p>
				<p>が実行されているものとする。</p>
				<div align="center">
					<table class="logic">
						<tr>
							<td><pre>
def enqueue (d:data)
	in(LAST,i:integer)
	out(QUEUE,d,i+1)
	out(LAST,i+1)
end


							</pre></td>
							<td><pre>
def dequeue()
    in(HEAD, j:integer) 
	read(LAST, i:integer > j)
	in(QUEUE,d:data,j)
	out(HEAD,j+1)
	return d
end							
							</pre></td>
						</tr>
					</table>
				</div>
				<br>
				<p>enqueueによって引数のデータを最後尾を示すLASTの位置に書き込む。</p>
				<p>dequeueは、LASTが先頭位置を示すHEADよりも大きいことを確認後にQUEUEからHEADの位置のデータを読み出し、削除する。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>初期設定として out(MUTEX,1)が実行されているものとする。</p>
				<pre>
def mutex(){
　　　in(MUTEX,i:integer >0)
      ～クリティカルセクション～
　　　out(MUTEX,1)
}
				</pre>
				<p>MUTEXの読み込みをクリティカルセクション(CS)の実行の条件とすることにより、CS実行中のプロセスが処理を終了しない限り、他のプロセスをMUTEXを確保するためにブロック状態となるため、排他制御が実現出来る。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>セマフォア構造体による排他制御を実現したプロセス間通信方式がある。セマフォアはそれぞれセマフォア名、セマフォア変数、待ち行列を持つ。プロセスはセマフォアを獲得してCS処理を行うか、獲得できない場合はセマフォアの待ち行列に入って待ち状態になる。CS処理を終えたプロセスはセマフォアを開放し、待ち行列にプロセスが存在する場合はそのプロセスを実行可能状態にさせ、存在しない場合はセマフォアを開放して処理を終える。</p>
				<p>排他制御を容易に実現出来るが、セマフォアの占有、開放の責任がユーザーにあることが欠点である。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第5問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>プリプロセッサが#で始まる命令を処理する。例としてC言語で</p>
				<p>#include&lt;math.c&gt;
					という宣言があれば、プリプロセッサはコンパイラ処理の前にmath.cをソースコード上に展開する。これをプリプロセッサ展開と呼ぶ。</p>
				<p>また、</p>
				<p>#define filename data.txt</p>
				<p>と書いておくと、この行以降のfilenameという文字列がコンパイル時に全てdata.txtに置換えられる。</p>
				<br>
				<p>マクロとは、プログラム中の文字列を特定の規則にしたがって置換することを言う。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>関数呼び出し時には呼び出し元に戻ってくることを考えて基本的にはデータの退避処理とジャンプ処理のためにオーバーヘッドが発生するが、マクロに書き換えることでこのオーバーヘッドを無くすことが可能。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>・f(g(y++))</p>
				<p>y++のインクリメントが行われるのは関数のリターン後であるため、f(g(y++))は</p>
				<p>f(g(y))</p>
				<p>y++;</p>
				<p>と同義。関数により算出された結果は、yがインクリメントされる前の値のものであるので、</p>
				<p>g(y) = y + 1</p>
				<p>f(y+1) = (y+1)*(y+1)</p>
				<br>
				<p>・F(G(y++))</p>
				<p>対してマクロで計算を行うG(x)はg(x)関数とは違い、yがインクリメントされた値に１を加算することになるので、</p>
				<p>G(y++) = (y++) + 1 = y + 2</p>
				<p>F(y+2) = (y+2)*(y+2)</p>
			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第6問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>輻輳とは，ネットワークが非常に混みあっており，正常な通信ができない状況のことです。通信が始まった直後では，経路のどこが混雑しているかわかりません。そのときに大量のデータを送信すると，輻輳が起こる危険があります。それを避けるために，輻輳ウインドウを設定しておき，通信開始時は一度に送る量を少なくして，ホストＢから返されるウインドウサイズとを比較しながら，次第に増やしていく方法をスロースタートといいます。これは輻輳制御の一つであり、輻輳によってデータ伝送の信頼性が損なわれないために必要である。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>スロースタートは、送信先から返されるウィンドウサイズと比較しながら、送信サイズを１から倍ずつウィンドウサイズを超えないところまで増加させていくアルゴリズム。</p>
				<br>
				<p>輻輳回避は、スロースタートで輻輳によるパケットの破棄が起こってしまった場合に使われる。最初はスロースタートと同様のアルゴリズムを使用するが、ウィンドウサイズの1/2を超えたところで、増加の単位を倍では無く、１とすることで輻輳を回避するアルゴリズム。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>TCPは輻輳回避フェーズにおいて2つのパラメータを用いる．</p>
				<p>AIMD( a, b )</p>
				<p>a：増加パラメータ</p>
				<p>b：減少パラメータ</p>
				<p>aは1ACKごとにcwndの値をa増やす．</p>
				<p>bはパケットロス時にcwndの値にbかける．</p>
				<br>
				<p>※輻輳ウィンドウサイズ cwnd</p>
				<p>通常は a = 1 , b = 0.5</p>
				<p>つまり１ずつ増え、失敗したら半分にする。</p>
				<br> <br>

				<h2>(4)</h2>
				<h3>(a)</h3>
				<p>1→2→4→8→16→32→64</p>
				<p>Ackを受信する度に上述のように送信サイズが増加するので、</p>
				<p>100msec * 7 = 700msec で輻輳回避状態へ移行する。</p>
				<p>転送サイズは1+2+4+8+16+32+64 = 127KBを送信済み。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>1→2→4→8→16→32→64→65→66→67→68→69→70→71→72→73→74→75→76→27</p>
				<p>およそ２秒？</p>
			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第7問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>3bit目（2^2）を否定してやるだけで他はそのまま出力すれば完成。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>※多数決回路とは、n入力のうち過半数を超える時、つまりはn/2+1入力以上１の時に出力が１になる回路のことらしい</p>
				<p>Oを出力として真理値表を作ると、</p>
				<div align="center">
					<table class="logic">
						<tr>
							<td>x</td>
							<td>y</td>
							<td>z</td>
							<td>O</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
						</tr>
					</table>
				</div>

				<p>カルノー図で簡約化すると</p>
				<p align="center">O = (x*y)+(y*z)+(x*z)</p>
				<p class="resizeimage">
					<img src="img_w/q7_1_2.png" alt="3入力多数決回路">
				</p>
				<br> <br>

				<h2>(3)</h2>
				<div align="center">
					<table class="logic">
						<tr>
							<td>x1</td>
							<td>x0</td>
							<td>a</td>
							<td>b</td>
							<td>c</td>
							<td>d</td>
							<td>e</td>
							<td>f</td>
							<td>g</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
						</tr>
					</table>
				</div>
				<br>
				<p>aとdの出力は等しい。bの出力は入力に関わらず１。fが１になる入力は１通りなので簡約化は不可能。</p>
				<p>以上より、a,c,e,gのみ簡約化すればよい。カルノー図を書くと、</p>
				<p class="resizeimage">
					<img src="img_w/q7_3_1.png" alt="a">
				</p>
				<br>
				<p class="resizeimage">
					<img src="img_w/q7_3_2.png" alt="c">
				</p>
				<br>
				<p class="resizeimage">
					<img src="img_w/q7_3_3.png" alt="e">
				</p>
				<br>
				<p class="resizeimage">
					<img src="img_w/q7_3_4.png" alt="y">
				</p>
				<br>
				<p class="resizeimage">
					<img src="img_w/q7_3_5.png" alt="デコーダー">
				</p>
				<br>
			</div>
		</div>


	</div>
</body>
</html>

