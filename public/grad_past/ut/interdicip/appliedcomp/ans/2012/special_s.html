<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース 2012年度 夏季募集 専門科目</title>
<!--#include virtual="/common/header.html" -->
</head>
<body>
<!--#include virtual="/common/navbar.html" -->	

	<div class="container well well-lg" style="background: red well">
		<h3>
			東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース<br>2012年度 夏季募集 専門科目
		</h3>
		<hr />

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第2問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>(1,1,1,1)</p>
				<p>(1,1,2),(1,2,1),(2,1,1)</p>
				<p>(1,3),(3,1)</p>
				<p>(2,2)</p>
				<p>より、a4 = 7</p>
				<br> <br>

				<h2>(2)</h2>
				<p>a_n = 1,2,4,7,11…</p>
				<p>数列 a_n に対して b_n = a_(n+1) - a_n とすると、</p>
				<p>階差数列 b_n = Σ(n,k=1)k</p>
				<p>よってa_n = 1 + Σ(n,k=1)k = 1/2 (n-1){(n-1)+1}= 1/2 (n^2-n+2)</p>
				<br> <br>

				<h2>(3)</h2>
				<p>(2)の漸化式を利用してa_nを求める方法であれば計算量はnに関わらず数回の単純な四則演算のみなので、O(1)であることは明らかである。</p>
				<br>
				<p></p>
				<p>全列挙する場合、木で表すとすれば木の最大の高さはnまで1点ずつ加算していく場合であるので、nとなる。1,2,3の３通りの加算方法があるので、完全3分木のノード数を考えると、初項１、公比３の等比数列の第n項までの和になるので、ノード数は1/2
					(3^n-1)個となる。1ノードの探索で定数時間c掛かるとすれば、計算時間は1/2 (3^n-1)c。</p>
				<p>よってO(3^n )となる。</p>
				<br> <br>

				<h2></h2>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第4問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<h3>(a)</h3>
				<p>35%</p>
				<br> <br>

				<h2>(b)</h2>
				<p>ページフォールト時に目的のページと、そのページにアドレスが連続するページを余分に読むこむデマンドプリフェッチをすれば、空間的局所性によりアクセスされるページに近いページは近いうちにアクセスされる確率が高いことが分かっているので、ヒット率を上げる効果が期待出来る。よって、時間の掛かるページフォールト率が下がるので、アクセス時間が向上する。</p>
				<p>また、プロセッサと主記憶に、主記憶よりさらに高速かつ小容量のキャッシュを数個設置することにより、ミスペナルティを緩和し、アクセス時間の向上が期待出来る。</p>
				<br> <br>

				<h2>(2)</h2>
				<h3>(a)</h3>
				<p>今までは基本的にCPUの動作周波数を向上させて高速化させてきたが、高クロック化は消費電力の増加、それによる熱暴走の問題が無視出来ないほどに大きくなった。さらにプロセッサの小型化によるリーク電流や、電子の物理的な速さの限界により、単一コアでの性能向上が非常に困難になった。そこで代わりに消費電力と発熱を抑え、スループットの向上により高速化が望めるマルチコアに方針を転換した。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>機械語レベルの並列実行可能な命令の検出、それぞれのコアに命令を配分する機構。マルチコアで最も大切なのは、いかに並列性を検出し、効率よくそれぞれのコアに仕事を割り振るかである。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第5問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<h3>(a)</h3>
				<p>複数のプロセスが互いに相手の占有している資源の開放を待ち、処理が停止してしまうこと。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>現在実行中のプロセスから、強制的に割り込みに応じた処理に実行権を移すこと。</p>
				<br> <br>

				<h3>(c)</h3>
				<p>単一の資源について、複数のプロセスが同時期にアクセスすると破綻をきたす可能性がある部分。クリティカルセクション中は、排他制御によってプリエンプションが起きないようにする必要がある。</p>
				<br> <br>

				<h3>(d)</h3>
				<p>あるプログラムがOSの機能を使用する場合に呼び出す命令。プログラミングにおいてはOS機能の関数呼び出しによって実現されている。</p>
				<br> <br>

				<h2>(2)</h2>
				<h3>(a)</h3>
				<p align="center">FIFO</p>

				<div align="center">

					<table class="logic">
						<tr>
							<td>枠１</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>4</td>
							<td>4</td>
							<td>4</td>
							<td>3</td>
							<td>3</td>
							<td>3</td>
							<td>3</td>
						</tr>
						<tr>
							<td>枠２</td>
							<td></td>
							<td>2</td>
							<td>2</td>
							<td>2</td>
							<td>2</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>4</td>
							<td>4</td>
							<td>4</td>
						</tr>
						<tr>
							<td>枠３</td>
							<td></td>
							<td></td>
							<td>3</td>
							<td>3</td>
							<td>3</td>
							<td>3</td>
							<td>2</td>
							<td>2</td>
							<td>2</td>
							<td>2</td>
							<td>2</td>
						</tr>
						<tr>
							<td>ページフォールト</td>
							<td>●</td>
							<td>●</td>
							<td>●</td>
							<td></td>
							<td>●</td>
							<td>●</td>
							<td>●</td>
							<td>●</td>
							<td>●</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>参照ページ</td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>2</td>
							<td>4</td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>4</td>
							<td>3</td>
							<td>2</td>
						</tr>
					</table>
				</div>
				<p align="center">ページフォールト計：８回</p>
				<br> <br>

				<h3>(b)</h3>
				<h3 align="center">LRU</h3>
				<div align="center">
					<table class="logic">
						<tr>
							<td>枠１(最近参照)</td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>2</td>
							<td>4</td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>4</td>
							<td>3</td>
							<td>2</td>
						</tr>
						<tr>
							<td>枠２</td>
							<td></td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>2</td>
							<td>4</td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>4</td>
							<td>3</td>
						</tr>
						<tr>
							<td>枠３(昔参照)</td>
							<td></td>
							<td></td>
							<td>1</td>
							<td>1</td>
							<td>3</td>
							<td>2</td>
							<td>4</td>
							<td>1</td>
							<td>2</td>
							<td>2</td>
							<td>4</td>
						</tr>
						<tr>
							<td>ページフォールト</td>
							<td>●</td>
							<td>●</td>
							<td>●</td>
							<td></td>
							<td>●</td>
							<td>●</td>
							<td></td>
							<td>●</td>
							<td>●</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>参照ページ</td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>2</td>
							<td>4</td>
							<td>1</td>
							<td>2</td>
							<td>3</td>
							<td>4</td>
							<td>3</td>
							<td>2</td>
						</tr>
					</table>
				</div>
				<p align="center">ページフォールト計：７回</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第6問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>TCP：Transmission Control Protocol</p>
				<p>UDP：User Datagram Protocol</p>
				<br> <br>

				<h2>(2)</h2>
				<p>・信頼性</p>
				<p>TCPは再送制御や誤り訂正機能を持ち、信頼性ある通信を行うのに対し、UDPはそういった機能を省いているために信頼性は低い。</p>
				<p>・速度</p>
				<p>TCPは信頼性確保のために冗長的な処理が多く、速度は遅い。UDPはそういった冗長的な処理を省いているため、比較的速い。</p>
				<p>・通信形態</p>
				<p>TCPは１対１通信であるユニキャストのみサポート。</p>
				<p>UDPはユニキャストに加え、１対多であるマルチキャストやブロードキャストをサポート。</p>
				<p>・輻輳制御</p>
				<p>TCPは輻輳制御機能を持ち、UDPは持たない。</p>
				<p>UDPはネットワークに負担を掛ける可能性が高い。</p>
				<p>しかしリアルタイム性は高い。</p>
				<p>・コネクション</p>
				<p>TCPはコネクション方式。UDPはコネクションレス方式。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>・速度</p>
				<p>(2)で挙げた通り、UDPは信頼性を犠牲にして高速な通信速度を実現している。これを生かし、リアルタイム性が重視される映像のストリーミングや、IP電話などに利用される。</p>
				<p>・マルチキャスト、ブロードキャスト</p>
				<p>１対多の通信を実現するためにはUDPが必要。</p>
				<p>・DNS</p>
				<p>DNSで使用するデータは極小であり、セグメントに分割する必要はない。少なくない要求に対して一々スリーハンドシェイクをしていたのでは無駄が非常に多い。そこでUDPの出番。</p>
				<br> <br>

				<h2>(4)</h2>
				<p>？？？</p>
				<br> <br>

				<h2>(5)</h2>
				<p>要求したパケットが正常に受信し、次に欲しいパケットの番号を送信側に伝えるため又は、受信に失敗したパケットの番号を伝えることで、再送を促す信号。コネクション確立、確実に受信出来たかの確認など、信頼性ある通信には必要。</p>
				<br> <br>

				<h2>(6)</h2>
				<p>データがパケットに分割されている場合、受信側が正しく分割されたパケットを結合するためには、パケットそれぞれに順序情報が必須。その順序を示すのがシーケンス番号。また、受信側はパケットの欠落も知ることが可能。信頼性ある通信に必要。</p>
				<br> <br>

				<h2>(7)</h2>
				<p>バッファが無ければ、１パケット送信する度に、相手のACKを待つ必要があり、非常に非効率。そこで相手のバッファ容量が許す限り、一度に複数のパケットを送信し、受信側は処理が追いつかない場合に一度バッファに受信パケットを溜めておくことによって、高速性を実現。送信バッファは、送信時にアプリケーションから受け取った際にデータを一時保管するために使用。</p>
				<br> <br>

				<h2>(8)</h2>
				<p>・スリーハンドシェイク</p>
				<p>SYN送信→ACK&SYN受信 ここまで100msec →ACK送信</p>
				<p>よって100msec</p>
				<p>・1MBファイルの送信</p>
				<p>1MB = 2^20 B</p>
				<p>64kB = 2^16 B</p>
				<p>→2^20/2^16 = 16個のパケットに分けて送信する必要がある。</p>
				<p>※1パケットで64kBのデータが送信出来ると仮定</p>
				<br>
				<p></p>
				<p>100msec * 16 = 1600 msec</p>
				<br>
				<p></p>
				<p>・コネクションを切る処理</p>
				<p>100msec</p>
				<br>
				<p></p>
				<p>以上よりおおよそ1800msec</p>
				<br> <br>

				<h2></h2>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第7問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>ド・モルガンの法則により、</p>
				<h3>(a)</h3>
				<p>¬F(x,y) = (¬x+y)*(x+¬y)</p>
				<br> <br>

				<h3>(b)</h3>
				<p>¬F(A,B,C,D,E) = (¬A+B)*¬C+D¬E</p>
				<br> <br>

				<h3>(c)</h3>
				<p>¬F(x,y,z) =¬ (¬xy¬z)+ (xz)+(¬(xy))</p>
				<br> <br>

				<h2>(2)</h2>
				<h3>(a)</h3>
				<p>複数のフリップフロップをカスケード接続にしたもので、記憶内容がその回路を一つずつ一方向に移動するようにしたもの。</p>
				<br> <br>

				<h3>(b)</h3>
				<p class="resizeimage">
					<img src="img_s/q7_2_b.png" alt="シフトレジスタ">
				</p>
				<p>右方向シフトレジスタ。</p>
				<p>桁送り信号がアサートされる度に記憶内容が右シフトしていく。</p>
				<br> <br>

				<h3>(c)</h3>
				<p>ネットワーク等でデータを送受信する場合に用いられる。ネットワークで使用する回線は通常１bitずつしかデータを送ることが出来ないため、受信側は1bitシフトレジスタに受信する度にシフトし、例えば8bit毎にフリップフロップの全てのデータを取り出せば、1bitずつ受信したデータを8bitに変換することが可能。</p>
			</div>
		</div>


	</div>
</body>
</html>

