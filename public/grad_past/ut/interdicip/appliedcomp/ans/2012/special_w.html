<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース 2012年度 冬季募集 専門科目</title>
<!--#include virtual="/common/header.html" -->
</head>
<body>
<!--#include virtual="/common/navbar.html" -->	

	<div class="container well well-lg" style="background: red well">
		<h3>
			東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース<br>2012年度 冬季募集 専門科目
		</h3>
		<hr />

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第2問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>(2,2,2)→(2,2,1)とひたすら列挙</p>
				<p>↓</p>
				<p>(2,2,0)</p>
				<br> <br>

				<h2>(2)</h2>
				<p>※著作権の関係で画像は掲載不可</p>
				<p>A:7 B:3 C:7 D:4 E:7 F:3 G:7 H:8 I:4 J:5 K:7 L:3 M:1 N:3 O:7
					P:4 Q:8 R:2 S:4 T:3 U:5 V:3</p>
				<br> <br>

				<h2>(3)</h2>
				<p>縦型探索なので、まずA→B→Eと進み、K,Lについて探索を行い、次にB→Fと進み、M,Nについて探索を行う。次にA→C→Gと進み、O,Pについて探索を行うと、Gの評価値は7となる。次にC→Hと進み、まずQについて探索を行うと、Qは8なのでGの評価値7よりも大きい値であることが分かる。この時点で後手番は自らの利益を考えればHを選択することは無いと予想出来るので、Rは探索する必要が無くなる。これをβカットと言う。</p>
				<p>次にA→D→Iと進み、S,Tを探索すると、Iの評価値は4となり、この時点でのDの最大評価値は4であることを意味する。これは探索済みであるBとCの評価値のうち、大きいCの評価値7よりも小さいので、Dに進むのは先手番の利益を考えればありえない選択になるため、これ以上探索する必要は無い。よってJの探索をする必要は無くなる。これをαカットと言う。</p>
				<br> <br>

				<h2>(4)</h2>
				<p>図で言えば左から評価の高い順の時？（αカット頻発）</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第4問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<h3>(a)</h3>
				<p>アクセスが許可されていないメモリ上の位置にアクセスもしくは許可されてない方法でアクセスしようとする場合に起きる。例えばユーザプログラムがリードライト禁止であるOSの部分を書き換えようとすればメモリ保護違反となり割り込み処理が発生し、エラーとなる。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>最後に入力したデータが最初に出力されるというFILO(First In Last
					Out)方式のデータ構造。プッシュダウン操作により新たにデータをスタックに積み、ポップアップ操作によりスタックからデータを取り出す。</p>
				<br> <br>

				<h3>(c)</h3>
				<p>スタックの位置を示すスタックポインタレジスタの指すメモリ上のアドレスをプッシュ、ポップ操作に応じて増減させることにより、メモリ上にスタック構造を実現する。</p>
				<br> <br>

				<h3>(d)</h3>
				<p>サブルーチン呼び出し等で呼び出し元のデータを一時的に格納しておくためにスタックが良く使われる。</p>
				<br> <br>

				<h2>(2)</h2>
				<h3>(a)</h3>
				<p>コンピュータがハードウェアや、ソフトウェアからの要求に応じて強制的に実行中のプログラムを差し置いて、割り込み原因に応じて割り込み処理に移ること。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>・ソフトウェア割り込み</p>
				<p>ゼロ除算やオーバーフロー、OSによるプリエンプション、ページフォールトなど、プログラム的な要因によって発生する割り込み。</p>
				<p>・ハードウェア割り込み</p>
				<p>ハードの物理的な故障や、入出力操作完了などのハード的な要因によって、ハードウェアがCPUに割り込みを要求することによって発生する割り込み。</p>
				<br> <br>

				<h3>(c)</h3>
				<p>まず割り込みルーチンを実行する前に、呼び出し元ルーチンに復帰した際に処理を行えるように、レジスタの値をメモリ上に退避する。これは(b)で説明したスタック構造が使われ、スタックポインタの位置にデータを退避した後に割り込みルーチンの実行。割り込みルーチンはプログラムを強制終了させるか復帰するが、復帰する場合はスタックに積まれているデータをポップし、割り込み直前の状態を再現させて処理を続行する。</p>
				<br> <br>

				<h3>(d)</h3>
				<p>割り込みの種類によって割り込み処理の内容は当然変わってくる。割り込み要求から得られる割り込み番号から、割り込みルーチンのアドレスを示すのが割り込みベクタ。割り込みベクタテーブル（表）から該当するアドレスを引いて、割り込み番号に割り当てられた処理を開始する。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第5問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>プロデューサ関数の、 count = count + 1;
					の処理が完了した直後にプリエンプションが発生し、コンシューマに実行権が移った場合、プロデューサーがまだデータをバッファーに入れてないのにも関わらずコンシューマはwhile(count==0)ループを抜け、無意味なデータbuffer[out]を読み込んでしまい正しくデータのやり取りが出来ない。</p>
				<br> <br>

				<h2>(2)</h2>
				<h3>(a)</h3>
				<p>If文の条件判定完了直後にプリエンプションが発生し、他のプロセスで条件判定結果覆すような処理が行われた場合に正しい処理が行われなくなるため。</p>
				<p>TS命令(Test&Set)はアトミック命令のため、処理途中にプリエンプションが発生しないことを保障する命令である。例えばv
					= TS( x )
					とした場合は、xの値をvに代入し、xの値を0にする処理を途中で割り込みされる余地を与えることなく行う命令であり、排他制御に使われる。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>もしs.queueの列にプロセスがあれば先頭のプロセスを実行可能状態にさせ、V命令を実行したプロセスも実行可能状態にする。無ければs.counterをインクリメントする。資源の開放操作を行う命令である。</p>
				<br> <br>

				<h2>(3)</h2>
				<div align="center">
					<table class="table table-striped table-bordered table-condensed">
						<tbody>
							<tr>
								<td colspan="2" style="padding-top: 40px"><pre>#define N 16
char buffer[N];
int in = 0;　int out = 0;
Semaphore mutexP=N;
Semaphore mutexC=0;
</pre></td>
							</tr>
							<tr>
								<td><pre>
void producer()
{
char c;
do {
	文字 c を生成する;
	P(mutexP);
	buffer[in] = c;
	V(mutexC);
	in = (in + 1) % N;
	} while (1);
}
</pre></td>
								<td><pre>
void consumer()
{
char c;
do {
	P(mutexC);
	c = buffer[out];
	V(mutexP);
	out = (out + 1) % N;
	文字 c を処理する;
	} while (1);
}
</pre></td>
							</tr>
						</tbody>
					</table>
				</div>
				<br> <br>

				<h2>(4)</h2>
				<div align="center">
					<table class="table table-striped table-bordered table-condensed">
						<tbody>
							<tr>
								<td colspan="2" style="padding-top: 40px"><pre>#define N 16
#define N 16
char buffer[N];
int in = 0;　int out = 0;
Semaphore mutexP=N;
Semaphore mutexC=0;
Semaphore output = 1;
</pre></td>
							</tr>
							<tr>
								<td><pre>
void producer()
{
char c;
do {
	文字 c を生成する;
	P(output);
	P(mutexP);
	buffer[in] = c;
	V(mutexC);
	in = (in + 1) % N;
	V(output);
	} while (1);
}
</pre></td>
								<td><pre>
void consumer()
{
char c;
do {
	P(mutexC);
	c = buffer[out];
	V(mutexP);
	out = (out + 1) % N;
	文字 c を処理する;
	} while (1);
}


</pre></td>
							</tr>
						</tbody>
					</table>
				</div>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第6問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>ISOが策定した、異機種間通信を円滑にするための標準規格。コンピュータの持つべき機能を７つの階層に区分。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>物理層→データリンク層→ネットワーク層→トランスポート層→セッション層→プレゼンテーション層→アプリケーション層</p>
				<div align="center">
					<table class="logic">
						<tr>
							<td>アプリケーション層</td>
							<td>ネットワークを通じて通信するアプリケーションが、相互にデータをやり取りするのに必要な共通のデータ構造などが規定される。最も有名なのが、wwwサーバーとクライアント間でのHTMLを中心とした情報のやり取りを規定するHTTP。電子メールを送信するためのSMTP,メールをサーバから受信するためのPOP,サーバーとクライアントの間に立ち、インターネット上のホスト名とIPアドレスを対応させるDNSなど。</td>
						</tr>
						<tr>
							<td>プレゼンテーション層</td>
							<td>ネットワークを流れるデータの意味を統一する機能を持つ層。例えば数値や文字は、コンピュータによって異なるコードで表されることがあるため、これを統一したコードに変換し、ネットワーク上のアプリケーション間で意味を統一しておく必要がある。</td>
						</tr>
						<tr>
							<td>セッション層</td>
							<td>トランスポート層での仮想的な回線において、通信の開始から終了までの一連の通信をセッションと呼ばれ、このセッションの管理を行うのがセッション層である。一般的に通信を行う場合は、要求を送り、応答を返すというように送受信の順番があり、このために双方で同期を取る必要がある。セッション層ではこの送受信の同期を管理する。</td>
						</tr>
						<tr>
							<td>トランスポート層</td>
							<td>端末同士でデータの送受信が正常に行われたかという管理と、信頼性の確保のための方式が規定。低速であるが信頼性が高いTCPや、高速であるが信頼性が低いUDPなどが一般的に使用されている。</td>
						</tr>
						<tr>
							<td>ネットワーク層</td>
							<td>ネットワーク同士の通信を行うための方式が規定。ネットワーク間でパケットを用いた通信を行うためのIPプロトコルや、相手のIPアドレスからMACアドレスを求めるARPや逆のRARPなどが使用されている。</td>
						</tr>
						<tr>
							<td>データリンク層</td>
							<td>物理層で直接接続されたノードの間、例えばイーサネットで接続されている複数のコンピュータの間でのデータの識別、経路の選択方式等の規定。データのパケット化や、信号の誤り訂正。このようなローカルなネットワークでは、イーサネットプロトコルがTCP/IPプロトコルと合わせて世界で標準的に利用されている。</td>
						</tr>
						<tr>
							<td>物理層</td>
							<td>物理的に機器や回線を繋いだり、切断するための電気的、機械的仕様の方式が規定。</td>
						</tr>
					</table>
				</div>
				<br> <br>

				<h2>(3)</h2>
				<h3>(a)</h3>
				<p>信頼性ある通信を売りとするTCPである可能性が高い。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>・フロー制御</p>
				<p>受信側の処理が追いつかず、バッファが溢れることを防ぐため、通信状況に応じて速度制限などの調整を行うこと。</p>
				<p>・輻輳制御</p>
				<p>ネットワークが輻輳状態になることを防ぐための制御。最初からウィンドウサイズ最大で送信するのは、ネットワークが輻輳状態であった場合に危険。そこで最初は極小サイズで送り始め、１ラウンドトリップ（往復）毎に転送量を２倍にする方法をスロースタートと呼ぶ。</p>
				<br> <br>

				<h3>(c)</h3>
				<h4>(i)</h4>
				<p>スロースタートでは、最初はCWNDを１とし、以後は１ラウンドトリップ毎に閾値まで２倍に増加し続ける。</p>
				<br> <br>
				<h4>(ii)</h4>
				<p>パケットミス→CWNDを１とすることを図に従って書く。</p>
				
			</div>
		</div>
		
	</div>
</body>
</html>

