<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース 2009年度 冬季募集 専門科目</title>
<!--#include virtual="/common/header.html" -->
</head>
<body>
<!--#include virtual="/common/navbar.html" -->	

	<div class="container well well-lg" style="background: red well">
		<h3>
			東京大学大学院 学際情報学府学際情報学専攻 総合分析情報学コース<br>2009年度 冬季募集 専門科目
		</h3>
		<hr />

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第2問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<pre>
int tmp;
While(1){
	while(a[i]&lt;pivot && i&lt;j)i++;
	while(a[j]&gt;pivot && i&lt;j)j--;
	if(i&gt;=j) break;
	tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
}
</pre>
				<br> <br>

				<h2>(2)</h2>
				<p>Qsort([3,5,4,2,1],0,4) pivot:3</p>
				<p>Qsort([1,2,4,5,3],0,1) pivot:1</p>
				<p>Qsort([1,2,4,5,3],2,4) pivot:4</p>
				<p>Qsort([1,2,3,5,4],3,4) pivot:5</p>
				<br>
				<p>→結果 [1,2,3,4,5]</p>
				<br> <br>

				<h2>(3)</h2>
				<p align="center">15を追加</p>
				<p class="resizeimage">
					<img src="img_w/q2_3_1.png" alt="B木">
				</p>
				<br>

				<p align="center">27を削除</p>
				<p class="resizeimage">
					<img src="img_w/q2_3_2.png" alt="B木">
				</p>
				<br> <br>

				<h2>(4)</h2>
				<p>最小：１５</p>
				<p>最大：３０</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第3問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>１つの命令を、 F：フェッチ D：デコード E：実行 M：メモリアクセス W：ライトバック
					の５ステージから構成されるとすると、ハザードが発生しない限りはある命令の処理が終わるまで他の命令は待つ必要は無く、ステージ毎に別々の１命令を処理していた方が効率が良いことは明らかである。図で表すとすれば、</p>
				<div align="center">
					<table class="logic">
						<tr>
							<td>命令A</td>
							<td>F</td>
							<td>D</td>
							<td>E</td>
							<td>M</td>
							<td>W</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>命令B</td>
							<td></td>
							<td>F</td>
							<td>D</td>
							<td>E</td>
							<td>M</td>
							<td>W</td>
							<td></td>
						</tr>
						<tr>
							<td>命令C</td>
							<td></td>
							<td></td>
							<td>F</td>
							<td>D</td>
							<td>E</td>
							<td>M</td>
							<td>W</td>
						</tr>
					</table>
				</div>
				<br> <br>

				<h2>(2)</h2>
				<h3>(a)</h3>
				<p>命令実行時に必要なデータの結果待ちのためにストールせざるを得ない状態。フォワーディング機構により起こりにくくさせることが可能。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>分岐命令の結果次第で後続の命令が変わるために起こるハザード。遅延分岐や、分岐予測により緩和可能。</p>
				<br> <br>

				<h3>(c)</h3>
				<p>同一のハードウェア資源を同時期に複数の命令が必要とする場合に発生。例えば２つの命令が１つのメモリに同時にアクセスすることは不可能であり、片方の命令はストールさせる必要がある。資源の多重化により解決出来る。</p>
				<br> <br>
				<h2>(3)</h2>
				<h3>(a)</h3>
				<p>通常のパイプラインは５ステージ程度だが、さらに細分化した数十ステージのパイプライン。動作周波数が向上し、ステージ毎の処理時間が均衡化されるためにパイプライン処理が効率化されるが、分岐予測が失敗した場合のペナルティも増加するため、単純に実行速度が向上するとは限らない。</p>
				<br> <br>

				<h3>(b)</h3>
				<p>パイプラインを複数使用し、複数の命令を同時実行することにより高速化を図る。命令レベルの依存性や、依存性をチェックする機構によるオーバーヘッドのために２本のパイプラインで２倍の処理速度を出すことは実際には困難。</p>
				<br> <br>

				<h3>(c)</h3>
				<p>依存関係に無い複数の命令を一つの命令として同時実行する。１命令が従来の命令に比べ非常に長くなるためにこの名がつけられた。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第4問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>・コンパイラ</p>
				<p>設計がインタプリタに比べると困難。ソースコードを事前に全て機械語に変換してから実行する。コンパイルの時間を要するが、実行時には無駄な処理が無く高速。</p>
				<p>・インタプリタ</p>
				<p>設計がコンパイラに比べれば容易。ソースコードを逐次解釈しながら実行する方法。事前にコンパイルする必要は無いが、実行時に機械語変換のオーバーヘッドが掛かるため、実行速度がコンパイラに比べて劣る。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>Java仮想マシンが有名。Java言語で開発されたソフトは、配布時にはプラットフォームから独立した独自のJavaバイトコード形式になっており、これをJava仮想マシンが実行するプラットフォームのネイティブコードに変換することにより実行する。インタプリタ形式のものをJVM。コンパイラ形式のものをJITコンパイラと呼ぶ。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>まずソースコードからコンパイラによりオブジェクトコードを生成したのち、リンカによってオブジェクトコードと必要なライブラリなどを付け加えて、機械語コードである実行ファイルが生成される。</p>
				<br>
				<p>字句解析</p>
				<p>構文解析</p>
				<p>意味解析</p>
				<p>最適化</p>
				<p>コード生成</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第5問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>・ページング方式</p>
				<p>物理メモリ空間、論理メモリ空間をページサイズ単位で分割し、同じ長さで分割したメモリのブロックにページテーブルによって対応付けする方式である。主記憶と補助記憶装置、場合によってはキャッシュメモリもページ単位でデータを送受信することで効率的なデータ管理を実現する。外部フラグメンテーションが発生しない。</p>
				<p>・セグメント方式</p>
				<p>ページング方式が固定長で分割していたのに対し、セグメント方式はデータやプログラムを可変な大きさのまとまりで管理する方式である。プログラムに割り当てるメモリが連続している必要があり、外部フラグメンテーションの問題がある。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>・ファーストフィットアルゴリズム</p>
				<p>(a)20KBの空き領域</p>
				<p>(b)10KBの空き領域</p>
				<p>(c)18KBの空き領域</p>
				<p>・ベストフィットアルゴリズム</p>
				<p>(a)12KBの空き領域</p>
				<p>(b)10KBの領域</p>
				<p>(c)9KBの領域</p>
				<p>・ワーストフィットアルゴリズム</p>
				<p>(a)20KBの領域</p>
				<p>(b)18KBの領域</p>
				<p>(c)15KBの領域</p>
				<br> <br>

				<h2>(3)</h2>
				<p>ウェアレベリング機能のあるOSを利用することで、SSDの弱点を緩和し、寿命を延ばすことが可能。書き込み限度回数はSSD全体に対しての回数では無く、記憶素子一つ一つに対しての回数である。ウェアレベリングにより、書き換えがひとつの素子に集中させず、均一に分散させれば、SSD全体としての書き換え限度回数は飛躍的に向上する。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第6問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>通信ネットワーク上の２点間を結ぶ閉じられた仮想的な直結回線を確立すること。</p>
				<p>本来通信を行いたいプロトコルで記述されたパケットを、別のプロトコルのパケットで包んで送り届けることによって通信を行う。これをカプセル化と呼ぶ。パケットのカプセル化と、その解除はトンネルの両端の機器が自動的に行うため、トンネルで結ばれた両端の機器同士は途中の通信方式や経路を気にする必要が無くなる。</p>
				<p>暗号化されることが多い。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>・セキュリティ</p>
				<p>いくらパケットを暗号化していても、公共回線にデータを流すのであればデータが盗み見られない保証は無い。</p>
				<p>・通信速度の保証</p>
				<p>公共回線なので、安定した通信帯域を要求する場合には適さない。</p>
				<br> <br>

				<h2>(3)</h2>
				<p>トンネリング機能に、さらに暗号化機能を備えているIPsecは広く利用されている。</p>
				<p>IPのパケットを暗号化するため、TCPやUDPなど上位層のプロトコルを気にする必要が無い。IPv4ではオプションとして利用可能。共通鍵暗号方式が使われ、暗号化アルゴリズムは特定のものに限定されておらず、様々な暗号アルゴリズムを利用可能。</p>
				<br> <br>

				<h2>(4)</h2>
				<p>あるネットワークを基盤として、その上に築かれた仮想的なネットワークのことをオーバーレイネットワークと呼ぶ。上位層ネットワーク利用者は、下層の形態や制御を意識することなく利用可能。</p>
				<p>トンネリングではインターネットを介した通信でも、あたかも同一LAN内でのやりとりに仮想的に見せかけることが可能であり、一種のオーバーレイネットワークであると言える。</p>
				<br> <br>

				<h2>(5)</h2>
				<p>サイズFをSに分割</p>
				<p>F/S個のパケットに分けて送信する。</p>
				<p>F + (F/S * h) を送信する必要がある。</p>
				<br>
				<p>(F + (F/S * h))/R</p>
				<br>
				<p>Sが大きければ大きいほど早くなる。</p>
				<p>つまり、セグメントサイズは大きければ大きいほどよい。これは送信先のネットワークのMTUに合わせて設定すればよい。</p>
				<br> <br>

				<h2>(6)</h2>
				<p>送信先ネットワークのMTUに合わせるだけでよい。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">第7問</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>※Xが素数のときにYに１を出力ぽい？</p>
				<p>4bitで表せる素数なので、 2,3,5,7,11,13 のときにYが１になる。</p>
				<br>
				<div align="center">
					<table class="logic">
						<tr>
							<td>X3</td>
							<td>X2</td>
							<td>X1</td>
							<td>X0</td>
							<td>Y</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
						</tr>
					</table>
				</div>
				<br>
				<p>真理値表より、</p>
				<p>Y = (¬(X3)*¬(X2)*X1*¬(X0))+ (¬(X3)*¬(X2)*X1*X0)+ (¬(X3)
					*X2*¬(X1)*X0)+ (¬(X3)*X2*X1*X0)+ (X3*¬(X2)*X1*X0)+ (X3*X2*¬(X1)
					*X0)</p>
				<br> <br>

				<h2>(4)</h2>
				<p>MOSトランジスタのサイズを、縦、横、高さ全てを1/2し、電圧を1/2にして使えば、トランジスタの動作が保証されると共に、スイッチングの高速化に加えて低消費電力になるという法則。→小さくすれば小さくするほど高速＆低消費電力になる。</p>
				<p>しかしながらナノスケールまで微細化されると物理的限界が見え始め、リーク電流や配線遅延の問題も無視できないほどになり、これ以上の小型化は困難であると言われている。</p>
			
			</div>
		</div>


	</div>
</body>
</html>

