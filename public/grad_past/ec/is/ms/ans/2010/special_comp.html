<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>電気通信大学大学院 情報システム学研究科 2010年度 専門科目 コンピュータ科学</title>
<!--#include virtual="/common/header.html" -->
</head>
<body>
<!--#include virtual="/common/navbar.html" -->	

	<div class="container well well-lg" style="background: red well">
		<h3>電気通信大学大学院 情報システム学研究科 2010年度 専門科目 コンピュータ科学</h3>
		<hr />

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">問題1</h3>
			</div>
			<div class="panel-body">
				<h2>問1</h2>
				<p>キャッシュ容量が1024ブロックならば、1024通り表せる分のbit数が必要。</p>
				<p>1024 = 2^10 なので10bit</p>
				<br> <br>

				<h2>問2</h2>
				<p>32bitのうち、問１よりインデックスが10bit、バイトオフセットが2bitなので、</p>
				<p>32 - 10 - 2 = 20 bit がタグフィールドに割り当てられる。</p>
				<br> <br>

				<h2>問3</h2>
				<p>キャッシュ容量：2^nブロック</p>
				<p>1ブロック：2^mワード</p>
				<p>１ワード：32bit(4byte)</p>
				<br>
				<p>よって</p>
				<p>インデックスフィールドがn bit</p>
				<p>ブロック内オフセットが m bit</p>
				<p>バイトオフセットが 2 bit</p>
				<p>であるので、</p>
				<p>タグフィールド ： (32 - n - m - 2) bit</p>
				<br> <br>

				<h2>問4</h2>
				<p>16kbyteのデータを保持するキャッシュ</p>
				<p>→16*2^10 = 2^4*2^10 = 2^14 byte</p>
				<br>
				<p>1ブロックは４語：4byte * 4 = 16byte</p>
				<p>ブロック数：2^14/16 = 2^14/2^4 = 2^10 個のブロック</p>
				<p>→10bitのインデックスフィールド</p>
				<br>
				<p>ブロック内オフセットは4=2^2より、2bit</p>
				<p>バイトオフセットも4byte = 2^2 byte より 2bit</p>
				<p>よってタグフィールドは</p>
				<p>32 - 10 - 2 - 2 = 18bit</p>
				<br>
				<p>ブロック数分のエントリ、つまり2^10個のエントリがあり、</p>
				<p>１エントリの構成は</p>
				<p>有効ビット : 1bit</p>
				<p>タグフィールド : 18 bit</p>
				<p>データ : 32bit(1語) * 4 = 128bit</p>
				<p>合計：147bit/1エントリ</p>
				<p>よって 必要な総ビット数は147*2^10bit</p>
				<br> <br>

				<h2>問5</h2>
				<p>例：バス幅、メモリバンク幅が１ワードの場合のミスペナルティ</p>
				<p>アドレス送出：1</p>
				<p>１ワードあたりのアクセス：15</p>
				<p>１ワード送出：1</p>
				<br>
				<p>ミスペナルティは1+(4*15)+4*1 = 65 メモリ・バス・クロック・サイクル</p>
				<p>(アドレス送出時間)+（１ワードあたりのアクセス時間）+（ワード送出時間）</p>
				<br> <br>

				<h3>問5-1</h3>
				<p>バス幅、メモリ幅４倍。</p>
				<p>アドレス送出：１</p>
				<p>４ワードあたりのアクセス：１５</p>
				<p>４ワード送出：1</p>
				<p>より、</p>
				<p>1 + 15 + 1 = 17 メモリ・バス・クロック・サイクル</p>
				<br> <br>

				<h3>問5-2</h3>
				<p>インタリーブ方式。</p>
				<p>アドレス送出：1*4</p>
				<p>4ワードアクセス：１５</p>
				<p>１ワード送出：1*4</p>
				<p>より、</p>
				<p>4+15+4＝23 メモリバスクロックサイクル</p>
				<br> <br>

				<h2>問6</h2>
				<p>・SRAM</p>
				<p>フリップフロップ回路で構成される記憶回路。リフレッシュが必要無く非常に高速であるが、回路が複雑で集積度が上げにくく、コストが高いため、大容量化には向かない。高速で小容量であるメモリとしてキャッシュメモリに使われている。</p>
				<br>
				<p>・DRAM</p>
				<p>コンデンサとトランジスタで構成された記憶素子。記憶内容が消失しないように一定時間毎に記憶内容を書き直すリフレッシュ操作が必要。SRAMより速度は劣るが、シンプルな構成で集積度を上げやすく、安価に大容量のメモリを実現。低速大容量のメモリとして主記憶に使われている。</p>
				<br>
				<p>SRAMとDRAMを組み合わせて互いの欠点を補うことにより、全体として近似的に高速大容量のメモリを実現する。</p>
				<br> <br>

				<h2>問7</h2>
				<p>・時間的局所性</p>
				<p>一度アクセスされたブロックは、近いうちに再度アクセスされる可能性が高いという経験則。最近アクセスされたブロックは追い出しの対象にしないようにすれば、ヒット率を上げることが可能。</p>
				<br>
				<p>・空間的局所性</p>
				<p>アクセスされたアドレスの周囲のアドレスは近いうちにアクセスされる可能性が高いという経験則。ブロックはアクセスされたアドレスの近くのアドレスもまとめてブロックとして送るので、この経験則に適う。</p>
			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">問題2</h3>
			</div>
			<div class="panel-body">
				<h2>問１</h2>
				<p>真ん中の子の中で最も左（値の小さい）の葉の値と、右の子の中で最も左の葉の値。</p>
				<p>子が２つの場合は右の子の中で最も左の葉の値。</p>
				<p>図３の例では、根はr4の６,r6の１０を保持することにより、６より小さい値は左の子で、６以上で１０より小さい値は真ん中の子、１０以上の値は右の子であると分類出来る。</p>
				<p>中間ノードも同様であり、例えばr1,r2,r3の親ノードには、r1,r2の値を保持する。</p>
				<br> <br>

				<h2>問2</h2>
				<p>★Java</p>
				<pre>
class node{
	int num1,num2;
	node left = new node();
	node mid = new node();
	node right = new node();

	node(){
	num1=0; num2=0;
	this.left = null;
	this.mid = null;
	this.right = null;	
	}
}
</pre>
				<br>
				<p>★C</p>
				<pre>struct node{
	int num1,num2;
	node *left,*mid,*right;
}
</pre>
				<br> <br>

				<h2>問3</h2>
				<p>range(x,y) x以上y以下のレコードを全て探す。</p>
				<p>バックトラック法の要領で検索途中のノードのアドレスをスタックに保持しておく。</p>
				<p>１， ｘを問１で示した性質に従って検索する。</p>
				<p>２， 発見したら４へ。見つからない場合はxをインクリメントして根から検索し直す。</p>
				<p>３， x &gt; y なら検索失敗として終了。 x&lt;=yなら１へ戻る。</p>
				<p>４， 値を出力</p>
				<p>５， 必要なだけ親ノードに戻り、右隣の葉に移動。</p>
				<p>６， 葉の値 &gt; y または 右隣の葉が無い場合は終了。それ以外は４へ。</p>
				<br> <br>

				<h2>問4</h2>
				<p>ノードが保持する情報を A , B 。または子が２つのときは A 。追加するレコードをXとする。</p>
				<p>１， X&lt;Aなら左の子へ。A&lt;X&lt;Bなら真ん中の子へ。B&lt;=Xなら右の子へ移動する。</p>
				<p>２， １を葉ノードの親ノードに着くまで繰り返す。</p>
				<p>３，
					Xと２つの葉ノードを昇順にソートし、中間の値と最大の値を親ノードの保持する情報として追加終了。既に３つの葉がある場合は４へ。</p>
				<p>４，
					木の再構成を行う必要がある。３つの葉とXでソートし、はみ出た葉を葉の空きがあるノードへ移動し、ノードの情報を問１で挙げたものに従って書き換えて終了。葉の空きが１つもない場合は５へ。</p>
				<p>５， 木の高さを１段増やして該当するノードへXを追加する。</p>
				<br> <br>

				<h2>問5</h2>
				<p class="resizeimage">
					<img src="img/comp_q2_5_1.png" alt="ツリー">
				</p>
				<p>レコード４を追加すると葉が４つになってしまうので、木の再構成を行うと、</p>
				<p class="resizeimage">
					<img src="img/comp_q2_5_2.png" alt="ツリー">
				</p>
			</div>
		</div>
	</div>

</body>
</html>

