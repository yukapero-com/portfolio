<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>電気通信大学大学院 情報システム学研究科 2011年度 専門科目 コンピュータ科学</title>
<!--#include virtual="/common/header.html" -->
</head>
<body>
<!--#include virtual="/common/navbar.html" -->	

	<div class="container well well-lg" style="background: red well">
		<h3>電気通信大学大学院 情報システム学研究科 2011年度 専門科目 コンピュータ科学</h3>
		<hr />

		<p>
			<!--#include file="test.html" -->
		</p>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">問題1</h3>
			</div>
			<div class="panel-body">
				<h2>問題１</h2>
				<h3>問1</h3>
				<p>２次元配列によってグラフの関係を示す。</p>
				<p>int graph[10] [10]= {</p>
				<div align="center">
					<table class="logic">
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
						</tr>
					</table>
				</div>
				<p>}</p>
				<br> <br>
				<h3>問２</h3>
				<pre>int N = 10;
int min[N]=∞;//全要素を∞に初期化
boolean OK[N] = false;//前要素をfalseに初期化。 
min[0] = 0;//出発地点の添字を0にする。
for(int i = 0;i&lt;N;i++){
	int M = min[N]のなかでOKがfalseかつ最小値を持つノードの添字
	OK[M] = true;
	for(int j = 0;j&lt;N;j++)
		if(min[M]+graph[M][j] &lt; min[j]　&& graph[M][j] != 0) 
			min[j] = min[M]+graph[M][j];
}</pre>
				<p>これをダイクストラ法と呼ぶ。</p>
				<br> <br>

				<h3>問3</h3>
				<p>各ノードまでの最短距離</p>
				<p>ノード０:始点なので経路無し</p>
				<p>ノード１:0→1</p>
				<p>ノード２:0→1→2</p>
				<p>ノード３:0→1→3</p>
				<p>ノード４:0→4</p>
				<p>ノード5:0→1→2→5</p>
				<p>ノード６:0→1→3→6</p>
				<p>ノード７:0→1→2→5→7</p>
				<p>ノード８:0→1→3→6→8</p>
				<p>ノード９:0→1→3→6→8→9</p>
				<br> <br>

				<h3>問4</h3>
				<p>０~９を始点にして逐次(2)を実行する。</p>
				<p>途中経路を保持しておき、経路上のノードをカウント。</p>
				<p>最後に最もカウント値の大きいノードを出力して終了。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">問題2</h3>
			</div>
			<div class="panel-body">
				<h2>問題1</h2>
				<h3>問1-1</h3>
				<p>主記憶のテーブルにアクセスし、該当するブロックをキャッシュに転送する。</p>
				<p>その後に改めてキャッシュからCPUに該当のデータが転送される。</p>
				<br> <br>

				<h3>問1-2</h3>
				<p>命令キャッシュミス率：Mi％ ヒット率：(1-Mi)％</p>
				<p>データキャッシュミス率：Md％ ヒット率：(1-Md)％</p>
				<p>キャッシュミス時の１命令：(Cn + Cp)クロック</p>
				<br>
				<p>・主記憶アクセス回数：I*Mi + I*R*Md = I( Mi + R*Md)</p>
				<p>・キャッシュヒット回数： I - I( Mi + R*Md) = I ( 1 ? Mi ? R*Md )</p>
				<br>
				<p>・必要クロック数：Cn*(キャッシュヒット回数) + (Cn+Cp)*(合計キャッシュミス回数)</p>
				<p>クロック</p>
				<p>よってプログラムPは、</p>
				<p>Cn*{ I ( 1 - Mi - R*Md ) } + (Cn + Cp){ I ( Mi + R*Md ) }
					クロックサイクル必要</p>
				<br>
				<p>１クロックに掛かる時間は1/F秒なので、</p>
				<p>1/F { Cn*{ I ( 1 - Mi - R*Md ) } + (Cn + Cp){ I ( Mi + R*Md )
					} } 秒となる。</p>
				<br> <br>

				<h3>問1-3</h3>
				<p>●1次キャッシュ</p>
				<p>・命令ミス率：Mi ％</p>
				<p>・データミス率：Md ％</p>
				<p>・１次ヒット１命令：Cnクロック</p>
				<br>
				<p>●２次キャッシュ</p>
				<p>・命令ミス率：Ms ％</p>
				<p>・データミス率：Ms ％</p>
				<p>・１次ミス、２次ヒット１命令：( Cr + Cs )クロック</p>
				<p>・１次ミス、２次ミス１命令：( Cr + Cm )クロック</p>
				<br>
				<p>・命令フェッチにおける１次ミス、２次ヒットの回数 ： I * Mi/100 * (1-Ms/100) 回</p>
				<p>★命令フェッチにおける１次ミス、２次ヒットの合計クロック数：</p>
				<p>(Cr+Cs){ I * Mi/100 * (1-Ms/100) }クロック</p>
				<br>
				<p>・命令フェッチにおける１次ミス、２次ミスの回数 ： I * Mi/100 * Ms/100 回</p>
				<p>★命令フェッチ１次ミス、２次ミスの合計クロック数 :</p>
				<p>(Cr+Cm){ I * Mi/100 * Ms/100 } クロック</p>
				<br>
				<p>・命令フェッチにおける１次ヒットの回数：</p>
				<p>(全命令数) - (1次ミス2次ヒット数) - (1次ミス2次ミス数)</p>
				<p>= I - { I * Mi/100 * (1-Ms/100) } ? { I * Mi/100 * Ms/100 }</p>
				<p>★命令フェッチにおける１次ヒット合計クロック数</p>
				<p>Cn * { I - { I * Mi/100 * (1-Ms/100) } ? { I * Mi/100 *
					Ms/100 } }クロック</p>
				<br>
				<p>・メモリアクセス回数：(I*R/100)回</p>
				<p>・データにおける１次ミス、２次ヒットの回数 : (I*R/100) * Md/100 * (1-Ms/100) 回</p>
				<p>★データにおける１次ミス、２次ヒットの合計クロック数：</p>
				<p>( Cr + Cs ){ (I*R/100) * Md/100 * (1-Ms/100) }クロック</p>
				<br>
				<p>・データにおける１次ミス、２次ミスの回数：(I*R/100)*Md/100*Ms/100 回</p>
				<p>★データにおける１次ミス、２次ミスの合計クロック数：</p>
				<p>( Cr + Cm ){ (I*R/100)*Md/100*Ms/100 } クロック</p>
				<br>
				<p>・データにおける１次ヒットの回数：</p>
				<p>(メモリアクセス数) - (1次ミス2次ヒット数) - (1次ミス2次ミス数)</p>
				<p>(I*R/100) - {(I*R/100) * Md/100 * (1-Ms/100)} ? {
					(I*R/100)*Md/100*Ms/100 }</p>
				<p>★データにおける１次ヒットの合計クロック数</p>
				<p>Cn * (I*R/100) - {(I*R/100) * Md/100 * (1-Ms/100)} ? {
					(I*R/100)*Md/100*Ms/100 }</p>
				<br>
				<p>プログラムPに必要なクロック数：</p>
				<p>+(命令フェッチにおける１次ヒット合計クロック数)</p>
				<p>+(命令フェッチにおける１次ミス、２次ヒットの合計クロック数)</p>
				<p>+(命令フェッチ１次ミス、２次ミスの合計クロック数)</p>
				<p>+(データにおける１次ヒットの合計クロック数)</p>
				<p>+(データにおける１次ミス、２次ヒットの合計クロック数)</p>
				<p>+(データにおける１次ミス、２次ミスの合計クロック数)</p>
				<br>
				<p>・1クロック：1/F 秒より、</p>
				<br>
				<p>プログラムPに必要な時間は</p>
				<p>1/F * (プログラムPに必要な合計クロック数)</p>
				<br> <br>

				<h2>問2</h2>
				<p>1語のブロックn個から構成されるキャッシュメモリ</p>
				<p>ダイレクトマッピング方式：1 way セットアソシアティブ方式</p>
				<p>フルアソシアティブ方式：n way セットアソシアティブ方式</p>
				<p>なので、</p>
				<p>m1 = 1</p>
				<p>m2 = n</p>
				<br> <br>

				<h2>問3</h2>
				<h3>問3-1</h3>
				<p>1mod3 = セット1</p>
				<p>5mod3 = セット2</p>
				<p>4mod3 = セット1</p>
				<p>なので、</p>
				<div align="center">
					<table class="logic">
						<tr>
							<td rowspan="2">セット０</td>
							<td></td>
						</tr>
						<tr>
							<td></td>
						</tr>
						<tr>
							<td rowspan="2">セット１</td>
							<td>４</td>
						</tr>
						<tr>
							<td>１</td>
						</tr>
						<tr>
							<td rowspan="2">セット２</td>
							<td>５</td>
						</tr>
						<tr>
							<td></td>
						</tr>
					</table>
				</div>
				<br>

				<p>※セット中で最も上に位置するものがセットの中で最も最近にアクセスされたブロックとする。</p>
				<br> <br>

				<h3>問3-2</h3>
				<p>1,5,4,1,7,4,5の順番でアクセス</p>
				<p>1mod3 = セット1：ミス</p>
				<p>5mod3 = セット2：ミス</p>
				<p>4mod3 = セット1：ミス</p>
				<p>1mod3 = セット1：ヒット！</p>
				<p>7mod3 = セット1：ミス</p>
				<p>4mod3 = セット1：ミス</p>
				<p>5mod3 = セット2：ヒット！</p>
				<p>なので、
				<div align="center">
					<table class="logic">
						<tr>
							<td rowspan="2">セット０</td>
							<td></td>
						</tr>
						<tr>
							<td></td>
						</tr>
						<tr>
							<td rowspan="2">セット１</td>
							<td>４</td>
						</tr>
						<tr>
							<td>7</td>
						</tr>
						<tr>
							<td rowspan="2">セット２</td>
							<td>５</td>
						</tr>
						<tr>
							<td></td>
						</tr>
					</table>
				</div>
				<br>
				<p>よって合計ミス数は５回</p>
				<br> <br>

				<h2>問4</h2>
				<p>(1) 初期参照ミス</p>
				<p>基本的には過去に一度もアクセスしてないブロックがキャッシュにあることは無い。よって、初めて参照したブロックは必ずキャッシュミスする。</p>
				<p>前もってブロックをキャッシュしておくことによって防止可能。</p>
				<p>(2) 容量性ミス</p>
				<p>キャッシュしたいブロック数が上回るといずれかのブロックを追い出さざるを得なくなる。追い出した後に、追い出したブロックにアクセスした場合に起きるミス。</p>
				<p>容量を増やすことによって防止可能。</p>
				<p>(3) 競合性ミス</p>
				<p>同じインデックスをもつ異なるブロックにアクセスすることで起こるミス。</p>
				<p>連想度を増やすことによって防止可能。</p>

			</div>
		</div>



	</div>


</body>
</html>

