<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>電気通信大学大学院 情報システム学研究科 2012年度 専門科目 コンピュータ科学</title>
<!--#include virtual="/common/header.html" -->
</head>
<body>
<!--#include virtual="/common/navbar.html" -->	

	<div class="container well well-lg" style="background: red well">
		<h3>電気通信大学大学院 情報システム学研究科 2012年度 専門科目 コンピュータ科学</h3>
		<hr />

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">問題1</h3>
			</div>
			<div class="panel-body">
				<h2>(1)</h2>
				<p>c言語の２次元配列でグラフの関係を示すと、</p>
				<br>

				<p>int data[6][6] ={</p>
				<div align="center">
					<table class="logic">
						<tr>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
						</tr>
					</table>
				</div>
				<p>}</p>
				<p>となる。</p>
				<p>例えばノード３とノード２は、data[3][2]またはdata[2][3]が１なので、連結していることが分かる。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>手順A：深さ優先探索</p>
				<p>０→１→２→３→８→５→４→６→７</p>
				<br>
				<p>手順B：幅優先探索</p>
				<p>０→１→２→７→８→３→５→６→４</p>
				<br> <br>

				<h2>(3)</h2>
				<p>幅優先探索によって連結成分を調べる方法を示す。</p>
				<p>初期状態としてノード数分の要素数を持つ、bool型の１次元配列flagを用意し、falseに初期化する。</p>
				<br>
				<p>1,探索開始ノードを待ち行列に入れ、flagの該当する添字をtrueにする。</p>
				<p>2,待ち行列の先頭ノードを取り出す。</p>
				<p>3,取り出したノードに繋がる辺を調べる。(1)で言うと１になっているインデックスが繋がっているノード。１になっていて、かつflagの該当する添字がfalseなら、trueにして待ち行列に入れる。</p>
				<p>4,待ち行列が空なら５へ。それ以外は２に戻る。</p>
				<p>5,flagの全ての要素がtrueならグラフは連結であり、一つでもfalseがあれば連結では無いと言える。</p>
				<br> <br>

				<h2>(2)</h2>
				<p>(4)</p>
				<p>(a)頂点を探索する順序</p>
				<p>・深さ優先探索</p>
				<p>出来るだけ探索開始地点から離れるように進み、行き止まりになったら直前の未訪問の分岐先に進みながら探索する方法。</p>
				<p>・幅優先探索</p>
				<p>探索開始地点に近いノードから探索する方法。</p>
				<br>
				<p>(b)使用メモリ効率</p>
				<p>・深さ優先探索</p>
				<p>スタックを用いて実装可能。スタックに積むのはこれから進むノードのインデックス情報のみであるので、最小限のメモリ容量で済む。</p>
				<p>・幅優先探索</p>
				<p>待ち行列を用いて実装可能。同じ高さのノードを全てエンキューしながら進まなくてはならないので効率は悪い。</p>
				<br>
				<p>(c)実行時間効率</p>
				<p>全探索においては双方の探索法の実行時間効率は同一であるが、深さ優先探索は分枝限定法などの探索高速化手法が適用可能であるため、幅優先探索よりも高速化させる余地を持っているため、深さ優先探索
					に軍配が上がる。</p>

			</div>
		</div>

		<br> <br> <br> <br>

		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">問題2</h3>
			</div>
			<div class="panel-body">
				<h2>問１</h2>
				<h3>(1)</h3>
				<p>例としてプロセスAがlockの３行目のst命令直前にプリエンプションが発生し、他のプロセスがlockを実行すると、2行目のbneを通過し、クリティカルセクション処理に入るが、途中で再度プリエンプションが発生するとプロセスAの処理が３行目から再開し、同時にクリティカルセクションを実行してしまうことになる。</p>
				<br> <br>

				<h3>(2)</h3>
				<p>セマフォアによる例を示す。</p>
				<p>P(x)：セマフォ変数xの値が１以上であるならばデクリメントする。０であるならば、ｘの待ち行列に入り、そのプロセスを待ち状態にする。</p>
				<p>V(x):セマフォxの待ち行列にプロセスが並んでいるならば、先頭のプロセスを実行可能状態にする。並んでいないならば、xのセマフォ変数をインクリメントする。</p>
				<br>
				<p>P命令、V命令はアトミック命令であるので、処理途中でプリエンプションされない。</p>
				<p>クリティカルセクションをP操作とV操作で挟むことにより、排他制御を実現する。</p>
				<br> <br>

				<h3>(3)</h3>
				<p>P命令がlock(f)に、V命令がunlock(f)にそのまま該当する。</p>
				<p>Semaphore X = 1;</p>
				<p>P(X);</p>
				<p>~クリティカルセクション~</p>
				<p>V(X)</p>
				<p>とすることで、クリティカルセクションが複数のプロセスに同時に実行されることは無い。</p>
				<br> <br>

				<h2>問２</h2>
				<h3>(1)</h3>
				<div align="center">
					<table class="logic">
						<tr>
							<td></td>
							<td>(ア)str 1 ,300</td>
							<td>(イ) jump 400</td>
						</tr>
						<tr>
							<td>IF</td>
							<td colspan="2">pcが示す番地の命令読み出し後に pc = pc + 4</td>
						</tr>
						<tr>
							<td rowspan="2">ID</td>
							<td colspan="2">命令の解読</td>
						</tr>
						<tr>
							<td>r1の内容を読み出す</td>
							<td>(動作無し)</td>
						</tr>
						<tr>
							<td>EX</td>
							<td>(動作無し)</td>
							<td>(動作無し)</td>
						</tr>
						<tr>
							<td>MA</td>
							<td>300番地にr1を書き込む</td>
							<td>（動作無し）</td>
						</tr>
						<tr>
							<td>WB</td>
							<td>(動作無し)</td>
							<td>pc = 400</td>
						</tr>
					</table>
				</div>
				<br> <br>

				<h3>(2)</h3>
				<p>データr2においてフロー依存がある。</p>
				<p>r2の値が確定するのはld命令のWB時であるため、add命令はr2が確定するまでストールせざるを得ない。</p>
				<br> <br>

				<h3>(3)</h3>
				<p>分岐ハザードとも言う。条件分岐によって後続の命令が確定しないために、分岐が確定するまで後続命令の命令フェッチをストールせざるを得ないことによって発生する。</p>
				<p>分岐予測によってある程度は改善可能。</p>
				<p>2bit分岐予測の例を示す。分岐が成立する度に00?11の範囲で2bit分岐予測をインクリメント。不成立の度にデクリメントする。この値を元に、</p>
				<p>00,01:分岐しないと予測 10,11:分岐すると予測</p>
				<p>として、予測した方の命令をフェッチする。予測が外れた場合はフラッシュして、正しい命令をフェッチする。</p>
				<br> <br>

				<h2>(3)</h2>
				<h3>(2)</h3>
				<div align="center">
					<table class="logic">
						<tr>
							<td></td>
							<td>古い参照</td>
							<td>最近参照</td>
						</tr>
						<tr>
							<td>0</td>
							<td>0008</td>
							<td>0EA0</td>
						</tr>
						<tr>
							<td>1</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>2</td>
							<td>10C2</td>
							<td>000A</td>
						</tr>
						<tr>
							<td>3</td>
							<td>302E</td>
							<td></td>
						</tr>
						<tr>
							<td>4</td>
							<td>3C3C</td>
							<td>0094</td>
						</tr>
						<tr>
							<td>5</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>6</td>
							<td>0006</td>
							<td></td>
						</tr>
						<tr>
							<td>7</td>
							<td></td>
							<td></td>
						</tr>
					</table>
				</div>
				<br>
				<p>キャッシュメモリは8＝2^3セットであるので、0~3bit目だけを見れば、どのセットに対応するのかが分かる。</p>
				<p>A:10 B:11 C:12 D:13 E:14 F:15</p>
				<p>下4桁を抜き出し、さらに下3桁分を10進数にしたセット番号の値をそれぞれ求めると、</p>
				<p>302E : 1110 → 110 → 3 (10) 初期参照ミス</p>
				<p>0EA0 : 0000 → 000 → 0 (10) 初期参照ミス</p>
				<p>0002 : 0010 → 010 → 2 (10)</p>
				<p>3C3C : 1100 → 100 → 4 (10) 初期参照ミス</p>
				<p>10C2 : 0010 → 010 → 2 (10) 初期参照ミス</p>
				<p>0094 : 0100 → 100 → 4 (10) 初期参照ミス</p>
				<p>000A : 1010 → 010 → 2 (10) 競合性ミス</p>
				<br> <br>

				<h3>(2)</h3>
				<p>・初期参照ミス：5回</p>
				<p>初めて参照したラインがキャッシュメモリ中にあることは基本的には無いので、必ずミスが発生する。</p>
				<p>・競合性ミス：1回</p>
				<p>同じインデックスの別のラインを参照することによるミス。</p>
				<br>
				<p>容量（Capacity）：
					プログラム実行に要するすべてのブロックを収容するだけの容量がキャッシュにないとき，いくつかのブロックがどうしてもキャッシュから追い出されることになり，それらに再度アクセスしようとしたときにミスが生じる．</p>
				<br>
				<p></p>
				<p>
					サイズを大きくするぐらいしか手がない．また，下位レベルに対して上位レベルのサイズが小さすぎると，転送が頻繁に生じてしまい，下位レベルのメモリ速度まで実行速度が低下してしまう．これをスラッシングと呼ぶ．</p>
				<br>
				<p></p>
				<p>競合（Conflict）：
					セットアソシアティブ方式，またはダイレクトマップ方式の場合に発生する．ある一つのセットに対応づけられているブロック数が，そのセットの物理ブロック数を超えている場合，どうしても幾つかのブロックがセットに入り切らずキャッシュから追い出されることになり，これらのブロックに再びアクセスしようとするときにミスが生じる．これらはコリジョン・ミスとも呼ばれる．</p>
				<br>
				<p>- フルアソシアティブ（フルマップ）にすれば生じないが，検索に時間がかかってしまう．</p>
				<br> <br>

				<h3>(3)</h3>
				<p>・ダイレクトマッピング方式</p>
				<p>・4way or 8way セットアソシアティブ方式</p>
				<p>・フルアソシアティブ方式</p>
				<br> <br>

				<h3>(4)</h3>
				<p>・フルアソシアティブ方式が最もキャッシュミス率を下げることが可能。</p>
				<p>LRU方式を採用し、最後に参照されてからの時間が長いほど若い番号が割り当てられるとする。</p>
				<br>
				<p>★恐らく4way、8wayセットアソシアティブ方式でもおｋ！</p>

				<div align="center">
					<table class="logic">
						<tr>
							<td>0</td>
							<td>0008</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0006</td>
						</tr>
						<tr>
							<td>2</td>
							<td>302E</td>
						</tr>
						<tr>
							<td>3</td>
							<td>0EA0</td>
						</tr>
						<tr>
							<td>4</td>
							<td>0002</td>
						</tr>
						<tr>
							<td>5</td>
							<td>3C3C</td>
						</tr>
						<tr>
							<td>6</td>
							<td>10C2</td>
						</tr>
						<tr>
							<td>7</td>
							<td>0094</td>
						</tr>
						<tr>
							<td>8</td>
							<td>000A</td>
						</tr>
						<tr>
							<td>9</td>
							<td></td>
						</tr>
						<tr>
							<td>10</td>
							<td></td>
						</tr>
						<tr>
							<td>11</td>
							<td></td>
						</tr>
						<tr>
							<td>12</td>
							<td></td>
						</tr>
						<tr>
							<td>13</td>
							<td></td>
						</tr>
						<tr>
							<td>14</td>
							<td></td>
						</tr>
						<tr>
							<td>15</td>
							<td></td>
						</tr>
					</table>
				</div>




			</div>
		</div>


	</div>

</body>
</html>

